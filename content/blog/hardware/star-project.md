---
title: 'ğŸ›°ï¸ "æ˜Ÿ"è®¡åˆ’ï¼šä¸€ä¸ªæŠ€æœ¯åºŸæŸ´çš„å¤ªç©ºæ¢ç´¢æ¢¦æƒ³'
description: 'ä»å¼€æºå°å«æ˜Ÿåˆ°ä¸ªäººæœåŠ¡å™¨ï¼Œä»ç¡¬ä»¶ç”µè·¯åˆ°æ§åˆ¶ç®—æ³•ï¼Œåˆ†äº«æˆ‘åœ¨å¤ªç©ºæŠ€æœ¯é¡¹ç›®ä¸­çš„å®Œæ•´å¼€å‘å†ç¨‹å’ŒæŠ€æœ¯å®ç°ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨ç¡¬ä»¶ç”µå­é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚'
date: '2020-05-24'
readTime: '12åˆ†é’Ÿ'
tags: ['ç”µå­è®¾è®¡', 'å¼€æºå«æ˜Ÿ', 'ç¡¬ä»¶ç”µè·¯', 'æ§åˆ¶ç®—æ³•', 'è½¯ä»¶ç³»ç»Ÿ', 'æŠ€æœ¯åºŸæŸ´', 'å¤ªç©ºæ¢ç´¢', 'è·¨ç•Œæ¢ç´¢']
category: 'ç¡¬ä»¶ç”µå­'
slug: 'star-project'
featured: false
author: 'LJoson'
status: 'published'
---

# ğŸ›°ï¸ "æ˜Ÿ"è®¡åˆ’ï¼šä¸€ä¸ªæŠ€æœ¯åºŸæŸ´çš„å¤ªç©ºæ¢ç´¢æ¢¦æƒ³

## é¡¹ç›®èµ·æºï¼šFossaSat-1çš„å¯å‘

åœ¨æµè§ˆæŠ€æœ¯æ–‡ç« æ—¶ï¼Œæˆ‘å¶ç„¶å‘ç°äº†ä¸€ä¸ªä»¤äººå…´å¥‹çš„å¼€æºé¡¹ç›®â€”â€”[FossaSat-1å¼€æºå«æ˜Ÿ](https://github.com/FOSSASystems/FOSSASAT-1)ã€‚

**é¡¹ç›®èƒŒæ™¯**ï¼š
- **ä½“ç§¯**ï¼š5Ã—5Ã—5cmï¼ˆç«‹æ–¹ä½“ï¼‰
- **é‡é‡**ï¼š250g
- **é€šä¿¡**ï¼šLORAæ¨¡å—
- **æˆæœ¬**ï¼šæä½ï¼Œé€‚åˆå­¦ç”Ÿé¡¹ç›®
- **å‘å°„æ—¶é—´**ï¼š2019å¹´åº•

**æŠ€æœ¯äº®ç‚¹**ï¼š
1. **LORAé€šä¿¡**ï¼šé¦–æ¬¡åœ¨å¤ªç©ºä½¿ç”¨LORAæŠ€æœ¯
2. **å¼€æºè®¾è®¡**ï¼šå®Œå…¨å¼€æºï¼Œä»»ä½•äººéƒ½å¯ä»¥å‚ä¸
3. **æ•™è‚²ä»·å€¼**ï¼šä¸“é—¨ç”¨äºæµ‹è¯•å­¦ç”Ÿä»£ç 
4. **æˆæœ¬æ§åˆ¶**ï¼šä½¿ç”¨å»‰ä»·ç»„ä»¶ï¼Œå¤§å¹…é™ä½æˆæœ¬

è¿™ä¸ªé¡¹ç›®è®©æˆ‘çœ‹åˆ°äº†å¤ªç©ºæŠ€æœ¯çš„å¹³æ°‘åŒ–å¯èƒ½æ€§ï¼Œæ¿€å‘äº†æˆ‘åŠ¨æ‰‹å®è·µçš„æ¬²æœ›ã€‚

## é¡¹ç›®è§„åˆ’ï¼šä»æ¦‚å¿µåˆ°å®ç°

### é¡¹ç›®ç›®æ ‡è®¾å®š

**æ ¸å¿ƒç›®æ ‡**ï¼š
- è®¾è®¡ä¸€ä¸ªå¾®å‹å«æ˜Ÿç³»ç»Ÿ
- å®ç°åŸºæœ¬çš„é€šä¿¡åŠŸèƒ½
- éªŒè¯æ§åˆ¶ç®—æ³•
- å»ºç«‹åœ°é¢ç«™ç³»ç»Ÿ

**æŠ€æœ¯æŒ‡æ ‡**ï¼š
- ç³»ç»Ÿä½“ç§¯ï¼š10Ã—10Ã—10cm
- æ€»é‡é‡ï¼š500gä»¥å†…
- é€šä¿¡è·ç¦»ï¼šåœ°é¢åˆ°ä½è½¨é“
- åŠŸè€—ï¼š5Wä»¥å†…
- æˆæœ¬ï¼š1000å…ƒä»¥å†…

**åº”ç”¨åœºæ™¯**ï¼š
- ä¸ªäººæœåŠ¡å™¨
- é›†ç¾¤æœåŠ¡å™¨
- æ•™è‚²æ¼”ç¤º
- æŠ€æœ¯éªŒè¯

### æŠ€æœ¯æ–¹æ¡ˆè®¾è®¡

**ç³»ç»Ÿæ¶æ„**ï¼š
```
å«æ˜Ÿç³»ç»Ÿ
â”œâ”€â”€ é€šä¿¡æ¨¡å—
â”‚   â”œâ”€â”€ LORAæ¨¡å—
â”‚   â”œâ”€â”€ å¤©çº¿ç³»ç»Ÿ
â”‚   â””â”€â”€ ä¿¡å·å¤„ç†
â”œâ”€â”€ æ§åˆ¶æ¨¡å—
â”‚   â”œâ”€â”€ å¾®æ§åˆ¶å™¨
â”‚   â”œâ”€â”€ ä¼ æ„Ÿå™¨
â”‚   â””â”€â”€ æ‰§è¡Œå™¨
â”œâ”€â”€ ç”µæºæ¨¡å—
â”‚   â”œâ”€â”€ å¤ªé˜³èƒ½ç”µæ± 
â”‚   â”œâ”€â”€ ç”µæ± ç®¡ç†
â”‚   â””â”€â”€ ç”µæºåˆ†é…
â””â”€â”€ ç»“æ„æ¨¡å—
    â”œâ”€â”€ å¤–å£³è®¾è®¡
    â”œâ”€â”€ æ•£çƒ­ç³»ç»Ÿ
    â””â”€â”€ é˜²æŠ¤ç³»ç»Ÿ
```

## ç¡¬ä»¶è®¾è®¡ï¼šä»ç”µè·¯åˆ°PCB

### é€šä¿¡æ¨¡å—è®¾è®¡

**LORAæ¨¡å—é€‰æ‹©**ï¼š
```c
// LORAæ¨¡å—é…ç½®
#define LORA_FREQUENCY 433.0E6  // 433MHzé¢‘æ®µ
#define LORA_TX_POWER 14        // å‘å°„åŠŸç‡14dBm
#define LORA_SPREADING_FACTOR 7 // æ‰©é¢‘å› å­
#define LORA_BANDWIDTH 125E3    // å¸¦å®½125kHz
#define LORA_CODING_RATE 5      // ç¼–ç ç‡4/5
```

**å¤©çº¿è®¾è®¡**ï¼š
```c
// å¤©çº¿å‚æ•°è®¡ç®—
float wavelength = 3e8 / 433e6;  // æ³¢é•¿çº¦0.69ç±³
float quarter_wavelength = wavelength / 4;  // å››åˆ†ä¹‹ä¸€æ³¢é•¿å¤©çº¿
float antenna_length = quarter_wavelength * 0.95;  // è€ƒè™‘ç¼©çŸ­ç³»æ•°
```

**æˆ‘çš„å®ç°**ï¼š
```c
// LORAé€šä¿¡åˆå§‹åŒ–
void lora_init() {
    LoRa.setPins(SS, RST, DIO0);

    if (!LoRa.begin(LORA_FREQUENCY)) {
        Serial.println("LoRaåˆå§‹åŒ–å¤±è´¥!");
        return;
    }

    LoRa.setTxPower(LORA_TX_POWER);
    LoRa.setSpreadingFactor(LORA_SPREADING_FACTOR);
    LoRa.setSignalBandwidth(LORA_BANDWIDTH);
    LoRa.setCodingRate4(LORA_CODING_RATE);

    Serial.println("LoRaåˆå§‹åŒ–æˆåŠŸ!");
}
```

### æ§åˆ¶æ¨¡å—è®¾è®¡

**å¾®æ§åˆ¶å™¨é€‰æ‹©**ï¼š
- **ä¸»æ§**ï¼šESP32ï¼ˆåŒæ ¸ï¼ŒWiFi+è“ç‰™ï¼‰
- **åå¤„ç†å™¨**ï¼šSTM32F103ï¼ˆå®æ—¶æ§åˆ¶ï¼‰
- **å­˜å‚¨**ï¼šSPI Flash 16MB

**ä¼ æ„Ÿå™¨é…ç½®**ï¼š
```c
// ä¼ æ„Ÿå™¨å®šä¹‰
#define MPU6050_ADDR 0x68      // é™€èºä»ªåŠ é€Ÿåº¦è®¡
#define BMP280_ADDR 0x76       // æ°”å‹æ¸©åº¦ä¼ æ„Ÿå™¨
#define TSL2561_ADDR 0x39      // å…‰ç…§ä¼ æ„Ÿå™¨
#define DS3231_ADDR 0x68       // å®æ—¶æ—¶é’Ÿ

// ä¼ æ„Ÿå™¨æ•°æ®ç»“æ„
typedef struct {
    float temperature;
    float pressure;
    float altitude;
    float light_intensity;
    float accel_x, accel_y, accel_z;
    float gyro_x, gyro_y, gyro_z;
    uint32_t timestamp;
} sensor_data_t;
```

**æˆ‘çš„å®ç°**ï¼š
```c
// ä¼ æ„Ÿå™¨åˆå§‹åŒ–
void sensors_init() {
    // åˆå§‹åŒ–MPU6050
    Wire.begin();
    Wire.beginTransmission(MPU6050_ADDR);
    Wire.write(0x6B);  // PWR_MGMT_1å¯„å­˜å™¨
    Wire.write(0);     // å”¤é†’MPU6050
    Wire.endTransmission(true);

    // åˆå§‹åŒ–BMP280
    if (!bmp.begin(BMP280_ADDR)) {
        Serial.println("BMP280åˆå§‹åŒ–å¤±è´¥!");
    }

    // åˆå§‹åŒ–TSL2561
    if (!tsl.begin(TSL2561_ADDR)) {
        Serial.println("TSL2561åˆå§‹åŒ–å¤±è´¥!");
    }

    Serial.println("æ‰€æœ‰ä¼ æ„Ÿå™¨åˆå§‹åŒ–å®Œæˆ!");
}

// è¯»å–ä¼ æ„Ÿå™¨æ•°æ®
sensor_data_t read_sensors() {
    sensor_data_t data;

    // è¯»å–MPU6050æ•°æ®
    Wire.beginTransmission(MPU6050_ADDR);
    Wire.write(0x3B);  // åŠ é€Ÿåº¦è®¡æ•°æ®å¯„å­˜å™¨
    Wire.endTransmission(false);
    Wire.requestFrom(MPU6050_ADDR, 14, true);

    data.accel_x = Wire.read() << 8 | Wire.read();
    data.accel_y = Wire.read() << 8 | Wire.read();
    data.accel_z = Wire.read() << 8 | Wire.read();
    data.temperature = Wire.read() << 8 | Wire.read();
    data.gyro_x = Wire.read() << 8 | Wire.read();
    data.gyro_y = Wire.read() << 8 | Wire.read();
    data.gyro_z = Wire.read() << 8 | Wire.read();

    // è¯»å–BMP280æ•°æ®
    data.pressure = bmp.readPressure();
    data.altitude = bmp.readAltitude(1013.25);

    // è¯»å–TSL2561æ•°æ®
    sensors_event_t event;
    tsl.getEvent(&event);
    data.light_intensity = event.light;

    data.timestamp = millis();

    return data;
}
```

### ç”µæºæ¨¡å—è®¾è®¡

**ç”µæºæ¶æ„**ï¼š
```c
// ç”µæºç®¡ç†å‚æ•°
#define SOLAR_VOLTAGE_MAX 5.0   // å¤ªé˜³èƒ½ç”µæ± æœ€å¤§ç”µå‹
#define BATTERY_VOLTAGE_MIN 3.0 // ç”µæ± æœ€ä½ç”µå‹
#define BATTERY_VOLTAGE_MAX 4.2 // ç”µæ± æœ€é«˜ç”µå‹
#define SYSTEM_VOLTAGE 3.3      // ç³»ç»Ÿå·¥ä½œç”µå‹

// ç”µæºçŠ¶æ€
typedef enum {
    POWER_SOLAR,    // å¤ªé˜³èƒ½ä¾›ç”µ
    POWER_BATTERY,  // ç”µæ± ä¾›ç”µ
    POWER_LOW,      // ä½ç”µé‡
    POWER_OFF       // å…³æœº
} power_state_t;
```

**æˆ‘çš„å®ç°**ï¼š
```c
// ç”µæºç®¡ç†
class PowerManager {
private:
    float battery_voltage;
    float solar_voltage;
    power_state_t current_state;

public:
    void init() {
        pinMode(SOLAR_PIN, INPUT);
        pinMode(BATTERY_PIN, INPUT);
        pinMode(CHARGE_PIN, OUTPUT);
        current_state = POWER_BATTERY;
    }

    void update() {
        battery_voltage = read_battery_voltage();
        solar_voltage = read_solar_voltage();

        // ç”µæºçŠ¶æ€åˆ¤æ–­
        if (solar_voltage > SOLAR_VOLTAGE_MAX * 0.8) {
            current_state = POWER_SOLAR;
            digitalWrite(CHARGE_PIN, HIGH);
        } else if (battery_voltage > BATTERY_VOLTAGE_MIN) {
            current_state = POWER_BATTERY;
            digitalWrite(CHARGE_PIN, LOW);
        } else {
            current_state = POWER_LOW;
            // è¿›å…¥ä½åŠŸè€—æ¨¡å¼
            enter_sleep_mode();
        }
    }

    float read_battery_voltage() {
        int raw = analogRead(BATTERY_PIN);
        return raw * (3.3 / 4095.0) * 2;  // åˆ†å‹ç”µè·¯
    }

    float read_solar_voltage() {
        int raw = analogRead(SOLAR_PIN);
        return raw * (3.3 / 4095.0) * 2;
    }

    void enter_sleep_mode() {
        // é…ç½®å”¤é†’æº
        esp_sleep_enable_timer_wakeup(30 * 1000000);  // 30ç§’åå”¤é†’
        esp_sleep_enable_ext0_wakeup(GPIO_NUM_0, 0);

        // è¿›å…¥æ·±åº¦ç¡çœ 
        esp_deep_sleep_start();
    }
};
```

## è½¯ä»¶ç³»ç»Ÿï¼šä»å›ºä»¶åˆ°åœ°é¢ç«™

### å›ºä»¶å¼€å‘

**ä¸»ç¨‹åºæ¶æ„**ï¼š
```c
// ä¸»ç¨‹åºç»“æ„
void setup() {
    Serial.begin(115200);

    // åˆå§‹åŒ–å„ä¸ªæ¨¡å—
    lora_init();
    sensors_init();
    power_manager.init();

    // å¯åŠ¨ä»»åŠ¡
    xTaskCreate(sensor_task, "Sensor", 2048, NULL, 1, NULL);
    xTaskCreate(communication_task, "Comm", 2048, NULL, 2, NULL);
    xTaskCreate(control_task, "Control", 2048, NULL, 3, NULL);

    Serial.println("å«æ˜Ÿç³»ç»Ÿå¯åŠ¨å®Œæˆ!");
}

void loop() {
    // ä¸»å¾ªç¯å¤„ç†
    power_manager.update();
    delay(1000);
}
```

**ä¼ æ„Ÿå™¨ä»»åŠ¡**ï¼š
```c
// ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ä»»åŠ¡
void sensor_task(void *parameter) {
    while (true) {
        sensor_data_t data = read_sensors();

        // æ•°æ®é¢„å¤„ç†
        data.accel_x /= 16384.0;  // è½¬æ¢ä¸ºg
        data.accel_y /= 16384.0;
        data.accel_z /= 16384.0;
        data.gyro_x /= 131.0;     // è½¬æ¢ä¸ºåº¦/ç§’
        data.gyro_y /= 131.0;
        data.gyro_z /= 131.0;

        // å­˜å‚¨æ•°æ®
        store_sensor_data(data);

        vTaskDelay(pdMS_TO_TICKS(1000));  // 1ç§’é‡‡é›†ä¸€æ¬¡
    }
}
```

**é€šä¿¡ä»»åŠ¡**ï¼š
```c
// é€šä¿¡ä»»åŠ¡
void communication_task(void *parameter) {
    while (true) {
        // æ£€æŸ¥æ˜¯å¦æœ‰æ¥æ”¶æ•°æ®
        int packetSize = LoRa.parsePacket();
        if (packetSize) {
            String received = "";
            while (LoRa.available()) {
                received += (char)LoRa.read();
            }

            // å¤„ç†æ¥æ”¶åˆ°çš„å‘½ä»¤
            process_command(received);
        }

        // å®šæœŸå‘é€é¥æµ‹æ•°æ®
        static uint32_t last_telemetry = 0;
        if (millis() - last_telemetry > 30000) {  // 30ç§’å‘é€ä¸€æ¬¡
            send_telemetry();
            last_telemetry = millis();
        }

        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

// å‘é€é¥æµ‹æ•°æ®
void send_telemetry() {
    sensor_data_t data = get_latest_sensor_data();

    String telemetry = "TELEMETRY:";
    telemetry += "TEMP:" + String(data.temperature, 2);
    telemetry += ",PRES:" + String(data.pressure, 2);
    telemetry += ",ALT:" + String(data.altitude, 2);
    telemetry += ",LIGHT:" + String(data.light_intensity, 2);
    telemetry += ",BAT:" + String(power_manager.read_battery_voltage(), 2);

    LoRa.beginPacket();
    LoRa.print(telemetry);
    LoRa.endPacket();

    Serial.println("å‘é€é¥æµ‹æ•°æ®: " + telemetry);
}
```

### åœ°é¢ç«™è½¯ä»¶

**Pythonåœ°é¢ç«™**ï¼š
```python
import serial
import tkinter as tk
from tkinter import ttk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import json
import threading
import time

class GroundStation:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("å«æ˜Ÿåœ°é¢ç«™")
        self.root.geometry("800x600")

        # ä¸²å£é…ç½®
        self.serial_port = None
        self.is_connected = False

        # æ•°æ®å­˜å‚¨
        self.telemetry_data = []

        self.setup_ui()

    def setup_ui(self):
        # è¿æ¥æ§åˆ¶åŒºåŸŸ
        connection_frame = ttk.LabelFrame(self.root, text="è¿æ¥æ§åˆ¶")
        connection_frame.pack(fill="x", padx=10, pady=5)

        ttk.Label(connection_frame, text="ä¸²å£:").grid(row=0, column=0, padx=5)
        self.port_var = tk.StringVar(value="COM3")
        port_combo = ttk.Combobox(connection_frame, textvariable=self.port_var)
        port_combo['values'] = ['COM1', 'COM2', 'COM3', 'COM4']
        port_combo.grid(row=0, column=1, padx=5)

        self.connect_btn = ttk.Button(connection_frame, text="è¿æ¥", command=self.toggle_connection)
        self.connect_btn.grid(row=0, column=2, padx=5)

        # é¥æµ‹æ•°æ®æ˜¾ç¤ºåŒºåŸŸ
        telemetry_frame = ttk.LabelFrame(self.root, text="é¥æµ‹æ•°æ®")
        telemetry_frame.pack(fill="both", expand=True, padx=10, pady=5)

        # åˆ›å»ºå›¾è¡¨
        self.fig, self.ax = plt.subplots(2, 2, figsize=(8, 6))
        self.canvas = FigureCanvasTkAgg(self.fig, telemetry_frame)
        self.canvas.get_tk_widget().pack(fill="both", expand=True)

        # å‘½ä»¤å‘é€åŒºåŸŸ
        command_frame = ttk.LabelFrame(self.root, text="å‘½ä»¤å‘é€")
        command_frame.pack(fill="x", padx=10, pady=5)

        ttk.Label(command_frame, text="å‘½ä»¤:").grid(row=0, column=0, padx=5)
        self.command_var = tk.StringVar()
        command_entry = ttk.Entry(command_frame, textvariable=self.command_var)
        command_entry.grid(row=0, column=1, padx=5, sticky="ew")

        send_btn = ttk.Button(command_frame, text="å‘é€", command=self.send_command)
        send_btn.grid(row=0, column=2, padx=5)

        command_frame.columnconfigure(1, weight=1)

    def toggle_connection(self):
        if not self.is_connected:
            try:
                self.serial_port = serial.Serial(self.port_var.get(), 115200, timeout=1)
                self.is_connected = True
                self.connect_btn.config(text="æ–­å¼€")

                # å¯åŠ¨æ•°æ®æ¥æ”¶çº¿ç¨‹
                self.receive_thread = threading.Thread(target=self.receive_data)
                self.receive_thread.daemon = True
                self.receive_thread.start()

            except Exception as e:
                tk.messagebox.showerror("é”™è¯¯", f"è¿æ¥å¤±è´¥: {e}")
        else:
            if self.serial_port:
                self.serial_port.close()
            self.is_connected = False
            self.connect_btn.config(text="è¿æ¥")

    def receive_data(self):
        while self.is_connected:
            try:
                if self.serial_port.in_waiting:
                    line = self.serial_port.readline().decode('utf-8').strip()
                    self.process_telemetry(line)
            except Exception as e:
                print(f"æ¥æ”¶æ•°æ®é”™è¯¯: {e}")
                break

    def process_telemetry(self, data):
        if data.startswith("TELEMETRY:"):
            # è§£æé¥æµ‹æ•°æ®
            parts = data.split(":")
            telemetry = {}
            for part in parts[1:]:
                if "," in part:
                    key, value = part.split(",")
                    telemetry[key] = float(value)

            self.telemetry_data.append(telemetry)
            self.update_plots()

    def update_plots(self):
        if len(self.telemetry_data) < 2:
            return

        # æ¸…é™¤æ—§å›¾è¡¨
        for ax in self.ax.flat:
            ax.clear()

        # æå–æ•°æ®
        times = range(len(self.telemetry_data))
        temps = [d.get('TEMP', 0) for d in self.telemetry_data]
        pressures = [d.get('PRES', 0) for d in self.telemetry_data]
        altitudes = [d.get('ALT', 0) for d in self.telemetry_data]
        batteries = [d.get('BAT', 0) for d in self.telemetry_data]

        # ç»˜åˆ¶å›¾è¡¨
        self.ax[0, 0].plot(times, temps)
        self.ax[0, 0].set_title('æ¸©åº¦')
        self.ax[0, 0].set_ylabel('Â°C')

        self.ax[0, 1].plot(times, pressures)
        self.ax[0, 1].set_title('æ°”å‹')
        self.ax[0, 1].set_ylabel('hPa')

        self.ax[1, 0].plot(times, altitudes)
        self.ax[1, 0].set_title('é«˜åº¦')
        self.ax[1, 0].set_ylabel('m')

        self.ax[1, 1].plot(times, batteries)
        self.ax[1, 1].set_title('ç”µæ± ç”µå‹')
        self.ax[1, 1].set_ylabel('V')

        self.canvas.draw()

    def send_command(self):
        if self.is_connected and self.serial_port:
            command = self.command_var.get()
            self.serial_port.write((command + '\n').encode())
            self.command_var.set("")

    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    station = GroundStation()
    station.run()
```

## æ§åˆ¶ç®—æ³•ï¼šä»å§¿æ€åˆ°è½¨é“

### å§¿æ€æ§åˆ¶ç³»ç»Ÿ

**PIDæ§åˆ¶å™¨**ï¼š
```c
// PIDæ§åˆ¶å™¨ç»“æ„
typedef struct {
    float kp, ki, kd;
    float setpoint;
    float error_sum;
    float last_error;
    float output_min, output_max;
} pid_controller_t;

// PIDæ§åˆ¶å™¨å®ç°
float pid_compute(pid_controller_t *pid, float input) {
    float error = pid->setpoint - input;
    pid->error_sum += error;

    // ç§¯åˆ†é™å¹…
    if (pid->error_sum > 1000) pid->error_sum = 1000;
    if (pid->error_sum < -1000) pid->error_sum = -1000;

    float derivative = error - pid->last_error;
    pid->last_error = error;

    float output = pid->kp * error + pid->ki * pid->error_sum + pid->kd * derivative;

    // è¾“å‡ºé™å¹…
    if (output > pid->output_max) output = pid->output_max;
    if (output < pid->output_min) output = pid->output_min;

    return output;
}
```

**å§¿æ€æ§åˆ¶ä»»åŠ¡**ï¼š
```c
// å§¿æ€æ§åˆ¶ä»»åŠ¡
void control_task(void *parameter) {
    // åˆå§‹åŒ–PIDæ§åˆ¶å™¨
    pid_controller_t roll_pid = {2.0, 0.1, 0.5, 0, 0, 0, -100, 100};
    pid_controller_t pitch_pid = {2.0, 0.1, 0.5, 0, 0, 0, -100, 100};
    pid_controller_t yaw_pid = {2.0, 0.1, 0.5, 0, 0, 0, -100, 100};

    while (true) {
        sensor_data_t data = get_latest_sensor_data();

        // è®¡ç®—å½“å‰å§¿æ€è§’
        float roll = atan2(data.accel_y, data.accel_z) * 180 / PI;
        float pitch = atan2(-data.accel_x, sqrt(data.accel_y * data.accel_y + data.accel_z * data.accel_z)) * 180 / PI;
        float yaw = atan2(data.gyro_y, data.gyro_x) * 180 / PI;

        // è®¡ç®—æ§åˆ¶è¾“å‡º
        float roll_output = pid_compute(&roll_pid, roll);
        float pitch_output = pid_compute(&pitch_pid, pitch);
        float yaw_output = pid_compute(&yaw_pid, yaw);

        // åº”ç”¨æ§åˆ¶è¾“å‡ºåˆ°æ‰§è¡Œå™¨
        apply_control_output(roll_output, pitch_output, yaw_output);

        vTaskDelay(pdMS_TO_TICKS(50));  // 20Hzæ§åˆ¶é¢‘ç‡
    }
}

// åº”ç”¨æ§åˆ¶è¾“å‡º
void apply_control_output(float roll, float pitch, float yaw) {
    // è¿™é‡Œå¯ä»¥æ§åˆ¶åä½œç”¨è½®æˆ–ç£åŠ›çŸ©å™¨
    // ç›®å‰ä½¿ç”¨LEDæŒ‡ç¤ºæ§åˆ¶çŠ¶æ€
    analogWrite(LED_ROLL, abs(roll) * 255 / 100);
    analogWrite(LED_PITCH, abs(pitch) * 255 / 100);
    analogWrite(LED_YAW, abs(yaw) * 255 / 100);
}
```

### è½¨é“æ§åˆ¶ç³»ç»Ÿ

**è½¨é“å‚æ•°è®¡ç®—**ï¼š
```c
// è½¨é“å‚æ•°ç»“æ„
typedef struct {
    float semi_major_axis;  // åŠé•¿è½´
    float eccentricity;     // åå¿ƒç‡
    float inclination;      // è½¨é“å€¾è§’
    float argument_of_perigee;  // è¿‘åœ°ç‚¹å¹…è§’
    float right_ascension;  // å‡äº¤ç‚¹èµ¤ç»
    float mean_anomaly;     // å¹³è¿‘ç‚¹è§’
} orbital_elements_t;

// è®¡ç®—è½¨é“å‚æ•°
orbital_elements_t calculate_orbital_elements(float altitude, float velocity) {
    orbital_elements_t elements;

    float mu = 398600.4418;  // åœ°çƒå¼•åŠ›å¸¸æ•° (kmÂ³/sÂ²)
    float r_earth = 6371.0;   // åœ°çƒåŠå¾„ (km)

    float r = r_earth + altitude / 1000.0;  // è½¨é“åŠå¾„ (km)
    float v = velocity / 1000.0;            // è½¨é“é€Ÿåº¦ (km/s)

    // è®¡ç®—åŠé•¿è½´
    elements.semi_major_axis = r;

    // è®¡ç®—åå¿ƒç‡ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
    elements.eccentricity = 0.0;  // å‡è®¾ä¸ºåœ†è½¨é“

    // å…¶ä»–å‚æ•°
    elements.inclination = 0.0;
    elements.argument_of_perigee = 0.0;
    elements.right_ascension = 0.0;
    elements.mean_anomaly = 0.0;

    return elements;
}
```

## æµ‹è¯•éªŒè¯ï¼šä»åœ°é¢åˆ°ç©ºä¸­

### åœ°é¢æµ‹è¯•

**åŠŸèƒ½æµ‹è¯•**ï¼š
```c
// ç³»ç»Ÿè‡ªæ£€
void system_self_test() {
    Serial.println("å¼€å§‹ç³»ç»Ÿè‡ªæ£€...");

    // æµ‹è¯•ä¼ æ„Ÿå™¨
    sensor_data_t data = read_sensors();
    Serial.printf("æ¸©åº¦: %.2fÂ°C\n", data.temperature);
    Serial.printf("æ°”å‹: %.2f hPa\n", data.pressure);
    Serial.printf("å…‰ç…§: %.2f lux\n", data.light_intensity);

    // æµ‹è¯•é€šä¿¡
    LoRa.beginPacket();
    LoRa.print("TEST:Hello from satellite!");
    LoRa.endPacket();
    Serial.println("é€šä¿¡æµ‹è¯•å®Œæˆ");

    // æµ‹è¯•ç”µæº
    float battery_voltage = power_manager.read_battery_voltage();
    Serial.printf("ç”µæ± ç”µå‹: %.2fV\n", battery_voltage);

    Serial.println("ç³»ç»Ÿè‡ªæ£€å®Œæˆ!");
}
```

**æ€§èƒ½æµ‹è¯•**ï¼š
```c
// æ€§èƒ½æµ‹è¯•
void performance_test() {
    Serial.println("å¼€å§‹æ€§èƒ½æµ‹è¯•...");

    // æµ‹è¯•æ•°æ®é‡‡é›†é¢‘ç‡
    uint32_t start_time = millis();
    for (int i = 0; i < 100; i++) {
        sensor_data_t data = read_sensors();
        delay(10);
    }
    uint32_t end_time = millis();

    float avg_time = (end_time - start_time) / 100.0;
    Serial.printf("å¹³å‡æ•°æ®é‡‡é›†æ—¶é—´: %.2f ms\n", avg_time);

    // æµ‹è¯•é€šä¿¡è·ç¦»
    int rssi = LoRa.packetRssi();
    Serial.printf("ä¿¡å·å¼ºåº¦: %d dBm\n", rssi);

    Serial.println("æ€§èƒ½æµ‹è¯•å®Œæˆ!");
}
```

### ç©ºä¸­æµ‹è¯•

**æ°”çƒæµ‹è¯•**ï¼š
```c
// æ°”çƒæµ‹è¯•æ¨¡å¼
void balloon_test_mode() {
    Serial.println("è¿›å…¥æ°”çƒæµ‹è¯•æ¨¡å¼...");

    while (true) {
        sensor_data_t data = read_sensors();

        // è®¡ç®—é«˜åº¦å˜åŒ–ç‡
        static float last_altitude = 0;
        float altitude_rate = (data.altitude - last_altitude) / 1.0;  // m/s
        last_altitude = data.altitude;

        // å‘é€æµ‹è¯•æ•°æ®
        String test_data = "BALLOON:";
        test_data += "ALT:" + String(data.altitude, 2);
        test_data += ",RATE:" + String(altitude_rate, 2);
        test_data += ",TEMP:" + String(data.temperature, 2);
        test_data += ",PRES:" + String(data.pressure, 2);

        LoRa.beginPacket();
        LoRa.print(test_data);
        LoRa.endPacket();

        Serial.println("å‘é€æ°”çƒæµ‹è¯•æ•°æ®: " + test_data);

        delay(5000);  // 5ç§’å‘é€ä¸€æ¬¡
    }
}
```

## é¡¹ç›®æˆæœï¼šä»å®éªŒåˆ°åº”ç”¨

### æŠ€æœ¯æˆæœ

**ç¡¬ä»¶æˆæœ**ï¼š
- å®Œæˆäº†å¾®å‹å«æ˜Ÿç³»ç»Ÿè®¾è®¡
- å®ç°äº†å¤šä¼ æ„Ÿå™¨é›†æˆ
- å»ºç«‹äº†å®Œæ•´çš„ç”µæºç®¡ç†ç³»ç»Ÿ
- éªŒè¯äº†LORAé€šä¿¡æŠ€æœ¯

**è½¯ä»¶æˆæœ**ï¼š
- å¼€å‘äº†å®Œæ•´çš„å›ºä»¶ç³»ç»Ÿ
- å®ç°äº†å®æ—¶æ•°æ®é‡‡é›†
- å»ºç«‹äº†åœ°é¢ç«™è½¯ä»¶
- éªŒè¯äº†æ§åˆ¶ç®—æ³•

**æµ‹è¯•æˆæœ**ï¼š
- å®Œæˆäº†åœ°é¢åŠŸèƒ½æµ‹è¯•
- è¿›è¡Œäº†æ°”çƒç©ºä¸­æµ‹è¯•
- éªŒè¯äº†é€šä¿¡ç³»ç»Ÿæ€§èƒ½
- æµ‹è¯•äº†ç”µæºç®¡ç†åŠŸèƒ½

### åº”ç”¨ä»·å€¼

**æ•™è‚²ä»·å€¼**ï¼š
- ä¸ºå¤ªç©ºæŠ€æœ¯æ•™è‚²æä¾›å®è·µå¹³å°
- é™ä½äº†å¤ªç©ºæŠ€æœ¯å­¦ä¹ é—¨æ§›
- æ¿€å‘äº†å­¦ç”Ÿå¯¹å¤ªç©ºæŠ€æœ¯çš„å…´è¶£
- æä¾›äº†å®Œæ•´çš„é¡¹ç›®å¼€å‘ç»éªŒ

**æŠ€æœ¯ä»·å€¼**ï¼š
- éªŒè¯äº†å¼€æºå¤ªç©ºæŠ€æœ¯çš„å¯è¡Œæ€§
- æ¢ç´¢äº†ä½æˆæœ¬å¤ªç©ºè§£å†³æ–¹æ¡ˆ
- ç§¯ç´¯äº†å¾®å‹å«æ˜Ÿå¼€å‘ç»éªŒ
- ä¸ºåç»­é¡¹ç›®å¥ å®šåŸºç¡€

**åˆ›æ–°ä»·å€¼**ï¼š
- æ¨åŠ¨äº†å¤ªç©ºæŠ€æœ¯å¹³æ°‘åŒ–
- æ¢ç´¢äº†æ–°çš„åº”ç”¨åœºæ™¯
- ä¿ƒè¿›äº†æŠ€æœ¯å¼€æºå…±äº«
- æ¿€å‘äº†æ›´å¤šåˆ›æ–°æƒ³æ³•

### ç»éªŒæ€»ç»“

**æŠ€æœ¯ç»éªŒ**ï¼š
1. **ç³»ç»Ÿé›†æˆ**ï¼šå¤šæ¨¡å—ç³»ç»Ÿçš„åè°ƒé…åˆ
2. **ç”µæºç®¡ç†**ï¼šä½åŠŸè€—è®¾è®¡çš„é‡è¦æ€§
3. **é€šä¿¡æŠ€æœ¯**ï¼šè¿œè·ç¦»é€šä¿¡çš„æŒ‘æˆ˜
4. **æ§åˆ¶ç®—æ³•**ï¼šå®æ—¶æ§åˆ¶ç³»ç»Ÿçš„å¤æ‚æ€§

**é¡¹ç›®ç®¡ç†ç»éªŒ**ï¼š
1. **éœ€æ±‚åˆ†æ**ï¼šæ˜ç¡®é¡¹ç›®ç›®æ ‡å’Œçº¦æŸ
2. **æŠ€æœ¯é€‰å‹**ï¼šå¹³è¡¡æ€§èƒ½å’Œæˆæœ¬
3. **æµ‹è¯•éªŒè¯**ï¼šåˆ†é˜¶æ®µéªŒè¯çš„é‡è¦æ€§
4. **æ–‡æ¡£ç®¡ç†**ï¼šæŠ€æœ¯æ–‡æ¡£çš„å®Œæ•´æ€§

**å›¢é˜Ÿåä½œç»éªŒ**ï¼š
1. **åˆ†å·¥åä½œ**ï¼šæ˜ç¡®å„äººèŒè´£
2. **æ²Ÿé€šåè°ƒ**ï¼šåŠæ—¶çš„æŠ€æœ¯äº¤æµ
3. **é—®é¢˜è§£å†³**ï¼šé›†ä½“æ™ºæ…§çš„å‘æŒ¥
4. **æˆæœåˆ†äº«**ï¼šçŸ¥è¯†çš„ä¼ æ‰¿å’Œæ‰©æ•£

## æœªæ¥å±•æœ›ï¼šä»ä¸ªäººåˆ°å›¢é˜Ÿ

### æŠ€æœ¯å‘å±•æ–¹å‘

**ç¡¬ä»¶å‡çº§**ï¼š
- é›†æˆæ›´å¤šä¼ æ„Ÿå™¨
- ä¼˜åŒ–ç”µæºç³»ç»Ÿ
- æ”¹è¿›é€šä¿¡æ¨¡å—
- å¢å¼ºé˜²æŠ¤èƒ½åŠ›

**è½¯ä»¶ä¼˜åŒ–**ï¼š
- å®Œå–„æ§åˆ¶ç®—æ³•
- ä¼˜åŒ–æ•°æ®å¤„ç†
- å¢å¼ºåœ°é¢ç«™åŠŸèƒ½
- å¼€å‘ç§»åŠ¨ç«¯åº”ç”¨

**ç³»ç»Ÿé›†æˆ**ï¼š
- å»ºç«‹å«æ˜Ÿç½‘ç»œ
- å®ç°é›†ç¾¤æ§åˆ¶
- å¼€å‘äº‘å¹³å°
- å»ºç«‹æ•°æ®ä¸­å¿ƒ

### åº”ç”¨æ‹“å±•æ–¹å‘

**æ•™è‚²åº”ç”¨**ï¼š
- å¼€å‘æ•™å­¦å¥—ä»¶
- å»ºç«‹åŸ¹è®­ä½“ç³»
- ç»„ç»‡ç«èµ›æ´»åŠ¨
- æ¨å¹¿å¼€æºæ–‡åŒ–

**å•†ä¸šåº”ç”¨**ï¼š
- ç‰©è”ç½‘é€šä¿¡
- ç¯å¢ƒç›‘æµ‹
- å†œä¸šåº”ç”¨
- ç‰©æµè¿½è¸ª

**ç§‘ç ”åº”ç”¨**ï¼š
- å¤§æ°”ç ”ç©¶
- åœ°çƒè§‚æµ‹
- ç©ºé—´å®éªŒ
- æŠ€æœ¯éªŒè¯

### å›¢é˜Ÿå»ºè®¾è®¡åˆ’

**äººæ‰æ‹›å‹Ÿ**ï¼š
- ç¡¬ä»¶å·¥ç¨‹å¸ˆ
- è½¯ä»¶å¼€å‘è€…
- ç®—æ³•ä¸“å®¶
- é¡¹ç›®ç®¡ç†

**èƒ½åŠ›å»ºè®¾**ï¼š
- æŠ€æœ¯åŸ¹è®­
- é¡¹ç›®å®è·µ
- ç»éªŒåˆ†äº«
- æŒç»­å­¦ä¹ 

**åˆä½œæ‹“å±•**ï¼š
- é«˜æ ¡åˆä½œ
- ä¼ä¸šåˆä½œ
- æ”¿åºœæ”¯æŒ
- å›½é™…äº¤æµ

## å‚è€ƒèµ„æ–™

### æŠ€æœ¯æ–‡æ¡£
- [FossaSat-1é¡¹ç›®æ–‡æ¡£](https://github.com/FOSSASystems/FOSSASAT-1)
- [ESP32å¼€å‘æŒ‡å—](https://docs.espressif.com/projects/esp-idf/en/latest/)
- [LoRaæŠ€æœ¯è§„èŒƒ](https://lora-alliance.org/)
- [å«æ˜Ÿè½¨é“åŠ›å­¦](https://en.wikipedia.org/wiki/Orbital_mechanics)

### å­¦ä¹ èµ„æº
- [Arduinoå«æ˜Ÿé¡¹ç›®](https://www.arduino.cc/en/Guide/ArduinoSatellite)
- [å¼€æºå¤ªç©ºæŠ€æœ¯](https://openspace.esa.int/)
- [CubeSatæ ‡å‡†](https://www.cubesat.org/)

### å·¥å…·è½¯ä»¶
- [KiCad PCBè®¾è®¡](https://www.kicad.org/)
- [Arduino IDE](https://www.arduino.cc/en/software)
- [Pythonåœ°é¢ç«™](https://www.python.org/)
- [MATLABä»¿çœŸ](https://www.mathworks.com/)

## ç»“è¯­

"æ˜Ÿ"è®¡åˆ’é¡¹ç›®è®©æˆ‘ä»ä¸€ä¸ªå¤ªç©ºæŠ€æœ¯çš„é—¨å¤–æ±‰æˆé•¿ä¸ºèƒ½å¤Ÿç‹¬ç«‹è®¾è®¡å’Œå®ç°å¾®å‹å«æ˜Ÿç³»ç»Ÿçš„å¼€å‘è€…ã€‚

ä»æœ€åˆçš„æ¦‚å¿µè®¾è®¡åˆ°æœ€ç»ˆçš„æµ‹è¯•éªŒè¯ï¼Œæ¯ä¸€ä¸ªé˜¶æ®µéƒ½è®©æˆ‘å¯¹å¤ªç©ºæŠ€æœ¯æœ‰äº†æ›´æ·±çš„ç†è§£ã€‚è™½ç„¶è¿™ä¸ªé¡¹ç›®è¿˜æœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†å®ƒè¯æ˜äº†å¼€æºå¤ªç©ºæŠ€æœ¯çš„å¯è¡Œæ€§å’Œä»·å€¼ã€‚

è¿™ä¸ªé¡¹ç›®ä¸ä»…æ˜¯ä¸€ä¸ªæŠ€æœ¯æˆæœï¼Œæ›´æ˜¯ä¸€ä¸ªæ¢¦æƒ³çš„å®ç°ã€‚å®ƒè®©æˆ‘ç›¸ä¿¡ï¼Œåªè¦æœ‰çƒ­æƒ…å’ŒåšæŒï¼ŒæŠ€æœ¯åºŸæŸ´ä¹Ÿèƒ½å‚ä¸åˆ°å¤ªç©ºæ¢ç´¢çš„ä¼Ÿå¤§äº‹ä¸šä¸­ã€‚

è®°ä½ï¼Œå¤ªç©ºä¸æ˜¯é¥ä¸å¯åŠçš„æ¢¦æƒ³ï¼Œè€Œæ˜¯å¯ä»¥é€šè¿‡æŠ€æœ¯æ‰‹æ®µå®ç°çš„ç›®æ ‡ã€‚æ¯ä¸€ä¸ªå°é¡¹ç›®éƒ½æ˜¯å‘å¤ªç©ºè¿ˆè¿›çš„ä¸€æ­¥ã€‚

---

> ğŸ’¡ **å®ç”¨å°è´´å£«**ï¼šå¤ªç©ºé¡¹ç›®è™½ç„¶å¤æ‚ï¼Œä½†å¯ä»¥ä»ç®€å•çš„æ¦‚å¿µéªŒè¯å¼€å§‹ã€‚å…ˆå®ç°åŸºæœ¬åŠŸèƒ½ï¼Œå†é€æ­¥å®Œå–„ã€‚è®°ä½ï¼Œæ¯ä¸€ä¸ªä¼Ÿå¤§çš„é¡¹ç›®éƒ½æ˜¯ä»ä¸€ä¸ªå°æƒ³æ³•å¼€å§‹çš„ï¼

*"åœ¨å¤ªç©ºæ¢ç´¢çš„ä¸–ç•Œé‡Œï¼Œè®©æŠ€æœ¯åºŸæŸ´ä¹Ÿèƒ½æˆä¸ºå¤ªç©ºæŠ€æœ¯ä¸“å®¶ï¼"* ğŸ›°ï¸
