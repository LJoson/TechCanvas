---
title: 'ğŸ® æ¸¸æˆå¼€å‘å®æˆ˜ï¼šä»åºŸæŸ´åˆ°ç‹¬ç«‹æ¸¸æˆå¼€å‘è€…'
description: 'æ¸¸æˆå¼€å‘å¬èµ·æ¥å¾ˆé…·ï¼Œä½†å®é™…åšèµ·æ¥æ‰å‘ç°å‘æœ‰å¤šæ·±ã€‚ä»æœ€åˆçš„"è´ªåƒè›‡"åˆ°åæ¥çš„"ä¿„ç½—æ–¯æ–¹å—"ï¼Œå†åˆ°ç°åœ¨çš„3Dæ¸¸æˆé¡¹ç›®ï¼Œæˆ‘è¸©è¿‡æ— æ•°å‘ï¼Œä¹Ÿå­¦åˆ°äº†å¾ˆå¤šç»éªŒï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨æ¸¸æˆå¼€å‘é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚'
date: '2023-12-20'
readTime: '30åˆ†é’Ÿ'
tags: ['æ¸¸æˆå¼€å‘', 'Unity', 'Unreal Engine', 'ç¼–ç¨‹æŠ€å·§', '3Då»ºæ¨¡', 'æ¸¸æˆè®¾è®¡', 'è·¨ç•Œæ¢ç´¢']
category: 'æ¸¸æˆå¼€å‘'
slug: 'game-development-practical'
featured: true
author: 'LJoson'
status: 'published'
---

# æ¸¸æˆå¼€å‘å®æˆ˜ï¼šä»åºŸæŸ´åˆ°ç‹¬ç«‹æ¸¸æˆå¼€å‘è€…

> æ¸¸æˆå¼€å‘å¬èµ·æ¥å¾ˆé…·ï¼Œä½†å®é™…åšèµ·æ¥æ‰å‘ç°å‘æœ‰å¤šæ·±

## å‰è¨€

ä½œä¸ºä¸€ä¸ªæŠ€æœ¯åºŸæŸ´ï¼Œæˆ‘ä¸€ç›´æ¢¦æƒ³ç€èƒ½åšå‡ºè‡ªå·±çš„æ¸¸æˆã€‚ä»æœ€åˆçš„"è´ªåƒè›‡"åˆ°åæ¥çš„"ä¿„ç½—æ–¯æ–¹å—"ï¼Œå†åˆ°ç°åœ¨çš„3Dæ¸¸æˆé¡¹ç›®ï¼Œæˆ‘è¸©è¿‡æ— æ•°å‘ï¼Œä¹Ÿå­¦åˆ°äº†å¾ˆå¤šç»éªŒã€‚

è¿™ç¯‡æ–‡ç« è®°å½•äº†æˆ‘ä»é›¶å¼€å§‹å­¦ä¹ æ¸¸æˆå¼€å‘çš„å¿ƒè·¯å†ç¨‹ï¼ŒåŒ…æ‹¬æŠ€æœ¯é€‰æ‹©ã€å¼€å‘æµç¨‹ã€å¸¸è§é—®é¢˜ç­‰ï¼Œå¸Œæœ›èƒ½å¸®åŠ©å…¶ä»–æƒ³è¦è¿›å…¥æ¸¸æˆå¼€å‘é¢†åŸŸçš„åºŸæŸ´ä»¬ã€‚

## æˆ‘çš„æ¸¸æˆå¼€å‘ä¹‹è·¯

### ç¬¬ä¸€é˜¶æ®µï¼šæ‡µæ‡‚æœŸ

åˆšå¼€å§‹æ¥è§¦æ¸¸æˆå¼€å‘æ—¶ï¼Œæˆ‘å®Œå…¨ä¸çŸ¥é“ä»ä½•ä¸‹æ‰‹ï¼š

- ä¸çŸ¥é“ç”¨ä»€ä¹ˆå¼•æ“
- ä¸çŸ¥é“å­¦ä»€ä¹ˆç¼–ç¨‹è¯­è¨€
- ä¸çŸ¥é“æ¸¸æˆå¼€å‘çš„åŸºæœ¬æµç¨‹
- ä¸çŸ¥é“å¦‚ä½•è®¾è®¡æ¸¸æˆæœºåˆ¶

é‚£æ—¶å€™çš„æˆ‘ï¼Œçœ‹åˆ°åˆ«äººåšçš„æ¸¸æˆè§‰å¾—å¾ˆé…·ï¼Œä½†è½®åˆ°è‡ªå·±åšçš„æ—¶å€™ï¼Œè¿ä¸ªç®€å•çš„è§’è‰²ç§»åŠ¨éƒ½æä¸å®šã€‚

### ç¬¬äºŒé˜¶æ®µï¼šå…¥é—¨æœŸ

ç»è¿‡ä¸€æ®µæ—¶é—´çš„æ‘¸ç´¢ï¼Œæˆ‘å¼€å§‹ç†è§£äº†ä¸€äº›åŸºç¡€æ¦‚å¿µï¼š

- **æ¸¸æˆå¼•æ“**ï¼šUnityã€Unreal Engineç­‰
- **ç¼–ç¨‹è¯­è¨€**ï¼šC#ã€C++ã€Pythonç­‰
- **æ¸¸æˆè®¾è®¡**ï¼šæœºåˆ¶è®¾è®¡ã€å…³å¡è®¾è®¡ã€UIè®¾è®¡ç­‰
- **ç¾æœ¯èµ„æº**ï¼š3Då»ºæ¨¡ã€è´´å›¾ã€åŠ¨ç”»ç­‰

### ç¬¬ä¸‰é˜¶æ®µï¼šå®è·µæœŸ

ç†è®ºç»“åˆå®è·µï¼Œæˆ‘å¼€å§‹åˆ¶ä½œä¸€äº›å°æ¸¸æˆï¼Œä»ç®€å•çš„2Dæ¸¸æˆå¼€å§‹ï¼Œé€æ­¥æé«˜éš¾åº¦ã€‚

## æŠ€æœ¯æ ˆé€‰æ‹©

### 1. æ¸¸æˆå¼•æ“å¯¹æ¯”

#### Unity

**ä¼˜ç‚¹ï¼š**
- å­¦ä¹ èµ„æºä¸°å¯Œ
- ç¤¾åŒºæ´»è·ƒ
- é€‚åˆåˆå­¦è€…
- è·¨å¹³å°æ”¯æŒå¥½
- 2D/3Déƒ½æ”¯æŒ

**ç¼ºç‚¹ï¼š**
- æ€§èƒ½ç›¸å¯¹è¾ƒä½
- å¤§å‹é¡¹ç›®å¯èƒ½é‡åˆ°æ€§èƒ½ç“¶é¢ˆ
- æ”¶è´¹æ”¿ç­–å˜åŒ–

**é€‚åˆäººç¾¤ï¼š** åˆå­¦è€…ã€ç‹¬ç«‹å¼€å‘è€…ã€2Dæ¸¸æˆå¼€å‘è€…

#### Unreal Engine

**ä¼˜ç‚¹ï¼š**
- æ€§èƒ½å¼ºå¤§
- å›¾å½¢æ¸²æŸ“ä¼˜ç§€
- é€‚åˆå¤§å‹é¡¹ç›®
- è“å›¾ç³»ç»Ÿé™ä½ç¼–ç¨‹é—¨æ§›

**ç¼ºç‚¹ï¼š**
- å­¦ä¹ æ›²çº¿é™¡å³­
- èµ„æºå ç”¨å¤§
- å¯¹ç¡¬ä»¶è¦æ±‚é«˜

**é€‚åˆäººç¾¤ï¼š** æœ‰ä¸€å®šåŸºç¡€ã€è¿½æ±‚é«˜å“è´¨ç”»é¢çš„å¼€å‘è€…

#### Godot

**ä¼˜ç‚¹ï¼š**
- å®Œå…¨å…è´¹å¼€æº
- è½»é‡çº§
- å†…ç½®è„šæœ¬è¯­è¨€GDScript
- ç¤¾åŒºå‹å¥½

**ç¼ºç‚¹ï¼š**
- ç”Ÿæ€ç›¸å¯¹è¾ƒå°
- ç¬¬ä¸‰æ–¹èµ„æºå°‘
- æ€§èƒ½ä¸å¦‚å•†ä¸šå¼•æ“

**é€‚åˆäººç¾¤ï¼š** é¢„ç®—æœ‰é™ã€å–œæ¬¢å¼€æºçš„å¼€å‘è€…

### 2. ç¼–ç¨‹è¯­è¨€é€‰æ‹©

#### C# (Unity)

```csharp
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    [SerializeField] private float moveSpeed = 5f;
    [SerializeField] private float jumpForce = 5f;

    private Rigidbody rb;
    private bool isGrounded;

    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }

    void Update()
    {
        // è·å–è¾“å…¥
        float horizontalInput = Input.GetAxis("Horizontal");
        float verticalInput = Input.GetAxis("Vertical");

        // ç§»åŠ¨
        Vector3 movement = new Vector3(horizontalInput, 0f, verticalInput);
        transform.Translate(movement * moveSpeed * Time.deltaTime);

        // è·³è·ƒ
        if (Input.GetKeyDown(KeyCode.Space) && isGrounded)
        {
            rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);
        }
    }

    void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.CompareTag("Ground"))
        {
            isGrounded = true;
        }
    }

    void OnCollisionExit(Collision collision)
    {
        if (collision.gameObject.CompareTag("Ground"))
        {
            isGrounded = false;
        }
    }
}
```

#### C++ (Unreal Engine)

```cpp
// PlayerController.h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "PlayerController.generated.h"

UCLASS()
class MYGAME_API APlayerController : public ACharacter
{
    GENERATED_BODY()

public:
    APlayerController();

protected:
    virtual void BeginPlay() override;

public:
    virtual void Tick(float DeltaTime) override;
    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

private:
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Movement", meta = (AllowPrivateAccess = "true"))
    float MoveSpeed = 500.0f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Movement", meta = (AllowPrivateAccess = "true"))
    float JumpForce = 500.0f;

    void MoveForward(float Value);
    void MoveRight(float Value);
    void Jump();
};

// PlayerController.cpp
#include "PlayerController.h"
#include "GameFramework/CharacterMovementComponent.h"

APlayerController::APlayerController()
{
    PrimaryActorTick.bCanEverTick = true;
}

void APlayerController::BeginPlay()
{
    Super::BeginPlay();
}

void APlayerController::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
}

void APlayerController::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
    Super::SetupPlayerInputComponent(PlayerInputComponent);

    PlayerInputComponent->BindAxis("MoveForward", this, &APlayerController::MoveForward);
    PlayerInputComponent->BindAxis("MoveRight", this, &APlayerController::MoveRight);
    PlayerInputComponent->BindAction("Jump", IE_Pressed, this, &APlayerController::Jump);
}

void APlayerController::MoveForward(float Value)
{
    if (Value != 0.0f)
    {
        AddMovementInput(GetActorForwardVector(), Value);
    }
}

void APlayerController::MoveRight(float Value)
{
    if (Value != 0.0f)
    {
        AddMovementInput(GetActorRightVector(), Value);
    }
}

void APlayerController::Jump()
{
    if (GetCharacterMovement()->IsFalling() == false)
    {
        LaunchCharacter(FVector(0.0f, 0.0f, JumpForce), false, true);
    }
}
```

#### GDScript (Godot)

```gdscript
extends CharacterBody3D

@export var speed = 5.0
@export var jump_velocity = 4.5

# Get the gravity from the project settings to be synced with RigidBody nodes.
var gravity = ProjectSettings.get_setting("physics/3d/default_gravity")

func _physics_process(delta):
    # Add the gravity.
    if not is_on_floor():
        velocity.y -= gravity * delta

    # Handle jump.
    if Input.is_action_just_pressed("ui_accept") and is_on_floor():
        velocity.y = jump_velocity

    # Get the input direction and handle the movement/deceleration.
    var input_dir = Input.get_vector("ui_left", "ui_right", "ui_up", "ui_down")
    var direction = (transform.basis * Vector3(input_dir.x, 0, input_dir.y)).normalized()
    if direction:
        velocity.x = direction.x * speed
        velocity.z = direction.z * speed
    else:
        velocity.x = move_toward(velocity.x, 0, speed)
        velocity.z = move_toward(velocity.z, 0, speed)

    move_and_slide()
```

## æ¸¸æˆå¼€å‘æµç¨‹

### 1. æ¸¸æˆè®¾è®¡é˜¶æ®µ

#### æ ¸å¿ƒæœºåˆ¶è®¾è®¡

```csharp
// æ¸¸æˆç®¡ç†å™¨ç¤ºä¾‹
public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }

    [Header("Game Settings")]
    public int maxHealth = 100;
    public int maxAmmo = 30;
    public float gameTime = 300f; // 5åˆ†é’Ÿ

    [Header("Player Stats")]
    public int currentHealth;
    public int currentAmmo;
    public int score;
    public float remainingTime;

    public enum GameState
    {
        MainMenu,
        Playing,
        Paused,
        GameOver,
        Victory
    }

    public GameState currentState;

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        InitializeGame();
    }

    void Update()
    {
        if (currentState == GameState.Playing)
        {
            UpdateGameTime();
            CheckGameOver();
        }
    }

    void InitializeGame()
    {
        currentHealth = maxHealth;
        currentAmmo = maxAmmo;
        score = 0;
        remainingTime = gameTime;
        currentState = GameState.Playing;
    }

    void UpdateGameTime()
    {
        remainingTime -= Time.deltaTime;
        if (remainingTime <= 0)
        {
            remainingTime = 0;
            GameOver();
        }
    }

    void CheckGameOver()
    {
        if (currentHealth <= 0)
        {
            GameOver();
        }
    }

    void GameOver()
    {
        currentState = GameState.GameOver;
        // æ˜¾ç¤ºæ¸¸æˆç»“æŸUI
    }

    public void TakeDamage(int damage)
    {
        currentHealth = Mathf.Max(0, currentHealth - damage);
    }

    public void AddScore(int points)
    {
        score += points;
    }

    public void Reload()
    {
        currentAmmo = maxAmmo;
    }
}
```

#### å…³å¡è®¾è®¡

```csharp
// å…³å¡ç®¡ç†å™¨
public class LevelManager : MonoBehaviour
{
    [System.Serializable]
    public class LevelData
    {
        public string levelName;
        public GameObject levelPrefab;
        public int targetScore;
        public float timeLimit;
        public int enemyCount;
    }

    public LevelData[] levels;
    public int currentLevelIndex = 0;

    public void LoadLevel(int levelIndex)
    {
        if (levelIndex >= 0 && levelIndex < levels.Length)
        {
            // å¸è½½å½“å‰å…³å¡
            UnloadCurrentLevel();

            // åŠ è½½æ–°å…³å¡
            currentLevelIndex = levelIndex;
            Instantiate(levels[levelIndex].levelPrefab);

            // è®¾ç½®å…³å¡å‚æ•°
            GameManager.Instance.gameTime = levels[levelIndex].timeLimit;
        }
    }

    public void NextLevel()
    {
        LoadLevel(currentLevelIndex + 1);
    }

    public void RestartLevel()
    {
        LoadLevel(currentLevelIndex);
    }

    void UnloadCurrentLevel()
    {
        // æ¸…ç†å½“å‰å…³å¡çš„æ‰€æœ‰å¯¹è±¡
        GameObject[] levelObjects = GameObject.FindGameObjectsWithTag("LevelObject");
        foreach (GameObject obj in levelObjects)
        {
            Destroy(obj);
        }
    }
}
```

### 2. å¼€å‘é˜¶æ®µ

#### è§’è‰²æ§åˆ¶ç³»ç»Ÿ

```csharp
// é«˜çº§è§’è‰²æ§åˆ¶å™¨
public class AdvancedPlayerController : MonoBehaviour
{
    [Header("Movement")]
    public float walkSpeed = 6f;
    public float runSpeed = 12f;
    public float jumpHeight = 2f;
    public float gravity = -9.81f;

    [Header("Camera")]
    public Camera playerCamera;
    public float mouseSensitivity = 2f;
    public float maxLookAngle = 80f;

    [Header("Ground Check")]
    public Transform groundCheck;
    public float groundDistance = 0.4f;
    public LayerMask groundMask;

    private CharacterController controller;
    private Vector3 velocity;
    private bool isGrounded;
    private float xRotation = 0f;

    void Start()
    {
        controller = GetComponent<CharacterController>();
        Cursor.lockState = CursorLockMode.Locked;
    }

    void Update()
    {
        HandleMovement();
        HandleMouseLook();
        HandleJump();
    }

    void HandleMovement()
    {
        // åœ°é¢æ£€æµ‹
        isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask);

        if (isGrounded && velocity.y < 0)
        {
            velocity.y = -2f;
        }

        // è·å–è¾“å…¥
        float x = Input.GetAxis("Horizontal");
        float z = Input.GetAxis("Vertical");

        // è®¡ç®—ç§»åŠ¨æ–¹å‘
        Vector3 move = transform.right * x + transform.forward * z;

        // é€‰æ‹©ç§»åŠ¨é€Ÿåº¦
        float currentSpeed = Input.GetKey(KeyCode.LeftShift) ? runSpeed : walkSpeed;

        // åº”ç”¨ç§»åŠ¨
        controller.Move(move * currentSpeed * Time.deltaTime);

        // åº”ç”¨é‡åŠ›
        velocity.y += gravity * Time.deltaTime;
        controller.Move(velocity * Time.deltaTime);
    }

    void HandleMouseLook()
    {
        float mouseX = Input.GetAxis("Mouse X") * mouseSensitivity;
        float mouseY = Input.GetAxis("Mouse Y") * mouseSensitivity;

        // å‚ç›´æ—‹è½¬ï¼ˆç›¸æœºï¼‰
        xRotation -= mouseY;
        xRotation = Mathf.Clamp(xRotation, -maxLookAngle, maxLookAngle);
        playerCamera.transform.localRotation = Quaternion.Euler(xRotation, 0f, 0f);

        // æ°´å¹³æ—‹è½¬ï¼ˆè§’è‰²ï¼‰
        transform.Rotate(Vector3.up * mouseX);
    }

    void HandleJump()
    {
        if (Input.GetButtonDown("Jump") && isGrounded)
        {
            velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity);
        }
    }
}
```

#### æ•ŒäººAIç³»ç»Ÿ

```csharp
// åŸºç¡€æ•ŒäººAI
public class EnemyAI : MonoBehaviour
{
    [Header("AI Settings")]
    public float detectionRange = 10f;
    public float attackRange = 2f;
    public float moveSpeed = 3f;
    public float attackDamage = 10f;
    public float attackCooldown = 1f;

    [Header("References")]
    public Transform player;
    public LayerMask playerMask;

    private NavMeshAgent agent;
    private Animator animator;
    private float lastAttackTime;
    private EnemyState currentState;

    public enum EnemyState
    {
        Idle,
        Patrol,
        Chase,
        Attack,
        Dead
    }

    void Start()
    {
        agent = GetComponent<NavMeshAgent>();
        animator = GetComponent<Animator>();
        currentState = EnemyState.Idle;

        if (player == null)
        {
            player = GameObject.FindGameObjectWithTag("Player").transform;
        }
    }

    void Update()
    {
        if (currentState == EnemyState.Dead) return;

        float distanceToPlayer = Vector3.Distance(transform.position, player.position);

        switch (currentState)
        {
            case EnemyState.Idle:
                HandleIdleState(distanceToPlayer);
                break;
            case EnemyState.Patrol:
                HandlePatrolState(distanceToPlayer);
                break;
            case EnemyState.Chase:
                HandleChaseState(distanceToPlayer);
                break;
            case EnemyState.Attack:
                HandleAttackState(distanceToPlayer);
                break;
        }
    }

    void HandleIdleState(float distanceToPlayer)
    {
        if (distanceToPlayer <= detectionRange)
        {
            currentState = EnemyState.Chase;
        }
        else
        {
            currentState = EnemyState.Patrol;
        }
    }

    void HandlePatrolState(float distanceToPlayer)
    {
        if (distanceToPlayer <= detectionRange)
        {
            currentState = EnemyState.Chase;
        }
        else
        {
            // å·¡é€»é€»è¾‘
            if (agent.remainingDistance < 0.5f)
            {
                SetRandomDestination();
            }
        }
    }

    void HandleChaseState(float distanceToPlayer)
    {
        if (distanceToPlayer > detectionRange)
        {
            currentState = EnemyState.Patrol;
        }
        else if (distanceToPlayer <= attackRange)
        {
            currentState = EnemyState.Attack;
        }
        else
        {
            // è¿½å‡»ç©å®¶
            agent.SetDestination(player.position);
            animator?.SetBool("IsChasing", true);
        }
    }

    void HandleAttackState(float distanceToPlayer)
    {
        if (distanceToPlayer > attackRange)
        {
            currentState = EnemyState.Chase;
            animator?.SetBool("IsAttacking", false);
        }
        else
        {
            // é¢å‘ç©å®¶
            transform.LookAt(player);

            // æ”»å‡»
            if (Time.time - lastAttackTime >= attackCooldown)
            {
                Attack();
                lastAttackTime = Time.time;
            }
        }
    }

    void Attack()
    {
        animator?.SetTrigger("Attack");

        // æ£€æµ‹æ”»å‡»æ˜¯å¦å‘½ä¸­
        if (Physics.Raycast(transform.position, transform.forward, out RaycastHit hit, attackRange, playerMask))
        {
            PlayerHealth playerHealth = hit.collider.GetComponent<PlayerHealth>();
            if (playerHealth != null)
            {
                playerHealth.TakeDamage(attackDamage);
            }
        }
    }

    void SetRandomDestination()
    {
        Vector3 randomDirection = Random.insideUnitSphere * 10f;
        randomDirection += transform.position;
        NavMeshHit hit;
        NavMesh.SamplePosition(randomDirection, out hit, 10f, 1);
        agent.SetDestination(hit.position);
    }

    public void TakeDamage(float damage)
    {
        // å¤„ç†å—ä¼¤é€»è¾‘
        animator?.SetTrigger("Hit");

        // å¦‚æœè¡€é‡å½’é›¶ï¼Œè¿›å…¥æ­»äº¡çŠ¶æ€
        if (/* è¡€é‡å½’é›¶ */)
        {
            Die();
        }
    }

    void Die()
    {
        currentState = EnemyState.Dead;
        animator?.SetTrigger("Die");
        agent.enabled = false;

        // å»¶è¿Ÿé”€æ¯
        Destroy(gameObject, 3f);
    }
}
```

### 3. æµ‹è¯•é˜¶æ®µ

#### å•å…ƒæµ‹è¯•

```csharp
// æ¸¸æˆé€»è¾‘æµ‹è¯•
public class GameLogicTests : MonoBehaviour
{
    [Header("Test Settings")]
    public bool runTestsOnStart = true;

    void Start()
    {
        if (runTestsOnStart)
        {
            RunAllTests();
        }
    }

    void RunAllTests()
    {
        TestPlayerMovement();
        TestEnemyAI();
        TestGameManager();
        TestScoreSystem();

        Debug.Log("æ‰€æœ‰æµ‹è¯•å®Œæˆï¼");
    }

    void TestPlayerMovement()
    {
        Debug.Log("æµ‹è¯•ç©å®¶ç§»åŠ¨...");

        // åˆ›å»ºæµ‹è¯•ç©å®¶
        GameObject testPlayer = new GameObject("TestPlayer");
        AdvancedPlayerController controller = testPlayer.AddComponent<AdvancedPlayerController>();

        // æµ‹è¯•ç§»åŠ¨é€Ÿåº¦
        // è¿™é‡Œå¯ä»¥æ·»åŠ å…·ä½“çš„æµ‹è¯•é€»è¾‘

        Debug.Log("ç©å®¶ç§»åŠ¨æµ‹è¯•é€šè¿‡ï¼");
        Destroy(testPlayer);
    }

    void TestEnemyAI()
    {
        Debug.Log("æµ‹è¯•æ•ŒäººAI...");

        // åˆ›å»ºæµ‹è¯•æ•Œäºº
        GameObject testEnemy = new GameObject("TestEnemy");
        EnemyAI ai = testEnemy.AddComponent<EnemyAI>();

        // æµ‹è¯•AIçŠ¶æ€è½¬æ¢
        // è¿™é‡Œå¯ä»¥æ·»åŠ å…·ä½“çš„æµ‹è¯•é€»è¾‘

        Debug.Log("æ•ŒäººAIæµ‹è¯•é€šè¿‡ï¼");
        Destroy(testEnemy);
    }

    void TestGameManager()
    {
        Debug.Log("æµ‹è¯•æ¸¸æˆç®¡ç†å™¨...");

        // æµ‹è¯•æ¸¸æˆçŠ¶æ€ç®¡ç†
        GameManager.Instance.InitializeGame();

        // æµ‹è¯•ä¼¤å®³ç³»ç»Ÿ
        GameManager.Instance.TakeDamage(10);

        // æµ‹è¯•è®¡åˆ†ç³»ç»Ÿ
        GameManager.Instance.AddScore(100);

        Debug.Log("æ¸¸æˆç®¡ç†å™¨æµ‹è¯•é€šè¿‡ï¼");
    }

    void TestScoreSystem()
    {
        Debug.Log("æµ‹è¯•è®¡åˆ†ç³»ç»Ÿ...");

        // æµ‹è¯•åˆ†æ•°è®¡ç®—
        int initialScore = GameManager.Instance.score;
        GameManager.Instance.AddScore(50);
        int finalScore = GameManager.Instance.score;

        if (finalScore == initialScore + 50)
        {
            Debug.Log("è®¡åˆ†ç³»ç»Ÿæµ‹è¯•é€šè¿‡ï¼");
        }
        else
        {
            Debug.LogError("è®¡åˆ†ç³»ç»Ÿæµ‹è¯•å¤±è´¥ï¼");
        }
    }
}
```

## å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### 1. æ€§èƒ½ä¼˜åŒ–

#### å¯¹è±¡æ± ç³»ç»Ÿ

```csharp
// å¯¹è±¡æ± ç®¡ç†å™¨
public class ObjectPool : MonoBehaviour
{
    [System.Serializable]
    public class Pool
    {
        public string tag;
        public GameObject prefab;
        public int size;
    }

    public List<Pool> pools;
    public Dictionary<string, Queue<GameObject>> poolDictionary;

    void Start()
    {
        poolDictionary = new Dictionary<string, Queue<GameObject>>();

        foreach (Pool pool in pools)
        {
            Queue<GameObject> objectPool = new Queue<GameObject>();

            for (int i = 0; i < pool.size; i++)
            {
                GameObject obj = Instantiate(pool.prefab);
                obj.SetActive(false);
                objectPool.Enqueue(obj);
            }

            poolDictionary.Add(pool.tag, objectPool);
        }
    }

    public GameObject SpawnFromPool(string tag, Vector3 position, Quaternion rotation)
    {
        if (!poolDictionary.ContainsKey(tag))
        {
            Debug.LogWarning($"Pool with tag {tag} doesn't exist.");
            return null;
        }

        GameObject objectToSpawn = poolDictionary[tag].Dequeue();

        if (objectToSpawn.activeInHierarchy)
        {
            // å¦‚æœæ± ä¸­æ²¡æœ‰å¯ç”¨å¯¹è±¡ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„
            objectToSpawn = Instantiate(pools.Find(p => p.tag == tag).prefab);
        }

        objectToSpawn.SetActive(true);
        objectToSpawn.transform.position = position;
        objectToSpawn.transform.rotation = rotation;

        poolDictionary[tag].Enqueue(objectToSpawn);

        return objectToSpawn;
    }
}

// ä½¿ç”¨å¯¹è±¡æ± çš„å­å¼¹ç³»ç»Ÿ
public class Bullet : MonoBehaviour
{
    public float speed = 20f;
    public float lifetime = 3f;

    void Start()
    {
        Invoke("ReturnToPool", lifetime);
    }

    void Update()
    {
        transform.Translate(Vector3.forward * speed * Time.deltaTime);
    }

    void ReturnToPool()
    {
        gameObject.SetActive(false);
    }

    void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Enemy"))
        {
            // å¤„ç†å‡»ä¸­é€»è¾‘
            ReturnToPool();
        }
    }
}
```

#### LODç³»ç»Ÿ

```csharp
// ç®€åŒ–çš„LODç³»ç»Ÿ
public class SimpleLOD : MonoBehaviour
{
    [System.Serializable]
    public class LODLevel
    {
        public GameObject model;
        public float distance;
    }

    public LODLevel[] lodLevels;
    public Transform player;

    private int currentLOD = 0;

    void Start()
    {
        if (player == null)
        {
            player = Camera.main.transform;
        }

        // åˆå§‹åŒ–LOD
        UpdateLOD();
    }

    void Update()
    {
        UpdateLOD();
    }

    void UpdateLOD()
    {
        float distance = Vector3.Distance(transform.position, player.position);

        for (int i = 0; i < lodLevels.Length; i++)
        {
            if (distance <= lodLevels[i].distance)
            {
                if (currentLOD != i)
                {
                    SetLODLevel(i);
                }
                break;
            }
        }
    }

    void SetLODLevel(int level)
    {
        // éšè—æ‰€æœ‰LODçº§åˆ«
        for (int i = 0; i < lodLevels.Length; i++)
        {
            if (lodLevels[i].model != null)
            {
                lodLevels[i].model.SetActive(i == level);
            }
        }

        currentLOD = level;
    }
}
```

### 2. å†…å­˜ç®¡ç†

```csharp
// èµ„æºç®¡ç†å™¨
public class ResourceManager : MonoBehaviour
{
    public static ResourceManager Instance { get; private set; }

    private Dictionary<string, UnityEngine.Object> cachedResources = new Dictionary<string, UnityEngine.Object>();

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public T LoadResource<T>(string path) where T : UnityEngine.Object
    {
        if (cachedResources.ContainsKey(path))
        {
            return cachedResources[path] as T;
        }

        T resource = Resources.Load<T>(path);
        if (resource != null)
        {
            cachedResources[path] = resource;
        }

        return resource;
    }

    public void ClearCache()
    {
        cachedResources.Clear();
        Resources.UnloadUnusedAssets();
    }

    void OnApplicationPause(bool pauseStatus)
    {
        if (pauseStatus)
        {
            // åº”ç”¨æš‚åœæ—¶æ¸…ç†å†…å­˜
            ClearCache();
        }
    }
}
```

## æ¸¸æˆå‘å¸ƒæµç¨‹

### 1. æ„å»ºè®¾ç½®

```csharp
// æ„å»ºé…ç½®ç®¡ç†å™¨
public class BuildConfig : MonoBehaviour
{
    [Header("Build Settings")]
    public bool enableDebugLogs = false;
    public bool enableProfiler = false;
    public bool enableDevelopmentBuild = false;

    [Header("Quality Settings")]
    public int targetFrameRate = 60;
    public bool vsyncEnabled = true;

    void Awake()
    {
        ConfigureBuild();
    }

    void ConfigureBuild()
    {
        // è®¾ç½®å¸§ç‡
        Application.targetFrameRate = targetFrameRate;

        // è®¾ç½®å‚ç›´åŒæ­¥
        QualitySettings.vSyncCount = vsyncEnabled ? 1 : 0;

        // æ ¹æ®æ„å»ºç±»å‹é…ç½®
        if (!enableDebugLogs)
        {
            Debug.unityLogger.logEnabled = false;
        }

        if (!enableProfiler)
        {
            Profiler.enabled = false;
        }

        // å¼€å‘æ„å»ºè®¾ç½®
        if (enableDevelopmentBuild)
        {
            Debug.Log("å¼€å‘æ„å»ºæ¨¡å¼å·²å¯ç”¨");
        }
    }
}
```

### 2. æ€§èƒ½ç›‘æ§

```csharp
// æ€§èƒ½ç›‘æ§å™¨
public class PerformanceMonitor : MonoBehaviour
{
    [Header("Monitoring")]
    public bool enableMonitoring = true;
    public float updateInterval = 0.5f;

    private float deltaTime = 0.0f;
    private float fps = 0.0f;
    private float memoryUsage = 0.0f;

    void Update()
    {
        if (!enableMonitoring) return;

        deltaTime += (Time.unscaledDeltaTime - deltaTime) * 0.1f;
        fps = 1.0f / deltaTime;

        memoryUsage = System.GC.GetTotalMemory(false) / 1024f / 1024f; // MB
    }

    void OnGUI()
    {
        if (!enableMonitoring) return;

        GUILayout.BeginArea(new Rect(10, 10, 200, 100));
        GUILayout.Label($"FPS: {fps:F1}");
        GUILayout.Label($"Memory: {memoryUsage:F1} MB");
        GUILayout.EndArea();
    }
}
```

## å­¦ä¹ èµ„æºæ¨è

### 1. å®˜æ–¹æ–‡æ¡£
- **Unity Learn**: Unityå®˜æ–¹å­¦ä¹ å¹³å°
- **Unreal Documentation**: UEå®˜æ–¹æ–‡æ¡£
- **Godot Documentation**: Godotå®˜æ–¹æ–‡æ¡£

### 2. åœ¨çº¿è¯¾ç¨‹
- **Udemy**: æœ‰å¾ˆå¤šæ¸¸æˆå¼€å‘è¯¾ç¨‹
- **Coursera**: è®¡ç®—æœºç§‘å­¦ç›¸å…³è¯¾ç¨‹
- **YouTube**: å…è´¹æ•™ç¨‹èµ„æºä¸°å¯Œ

### 3. ç¤¾åŒºèµ„æº
- **Unity Forum**: Unityå®˜æ–¹è®ºå›
- **Reddit r/gamedev**: æ¸¸æˆå¼€å‘ç¤¾åŒº
- **Stack Overflow**: æŠ€æœ¯é—®é¢˜è§£ç­”

## æ€»ç»“

æ¸¸æˆå¼€å‘æ˜¯ä¸€ä¸ªå¤æ‚è€Œæœ‰è¶£çš„è¿‡ç¨‹ï¼Œéœ€è¦æŒæ¡å¤šä¸ªé¢†åŸŸçš„çŸ¥è¯†ã€‚ä½œä¸ºä¸€ä¸ªæŠ€æœ¯åºŸæŸ´ï¼Œæˆ‘çš„å»ºè®®æ˜¯ï¼š

1. **ä»ç®€å•å¼€å§‹**ï¼šå…ˆåšç®€å•çš„2Dæ¸¸æˆï¼Œé€æ­¥æé«˜éš¾åº¦
2. **é€‰æ‹©åˆé€‚çš„æŠ€æœ¯æ ˆ**ï¼šæ ¹æ®é¡¹ç›®éœ€æ±‚å’Œä¸ªäººèƒ½åŠ›é€‰æ‹©
3. **æ³¨é‡æ€§èƒ½ä¼˜åŒ–**ï¼šæ¸¸æˆæ€§èƒ½ç›´æ¥å½±å“ç”¨æˆ·ä½“éªŒ
4. **æŒç»­å­¦ä¹ **ï¼šæ¸¸æˆå¼€å‘æŠ€æœ¯æ›´æ–°å¾ˆå¿«ï¼Œè¦ä¸æ–­å­¦ä¹ 
5. **å¤šå®è·µ**ï¼šç†è®ºç»“åˆå®è·µï¼Œå¤šåšé¡¹ç›®

è®°ä½ï¼Œæ¯ä¸ªæ¸¸æˆå¼€å‘è€…éƒ½æ˜¯ä»åºŸæŸ´å¼€å§‹çš„ã€‚åªè¦åšæŒå­¦ä¹ ï¼Œæ€»æœ‰ä¸€å¤©ä½ ä¹Ÿèƒ½åšå‡ºè‡ªå·±çš„æ¸¸æˆï¼

---

*æ ‡ç­¾ï¼šæ¸¸æˆå¼€å‘, Unity, Unreal Engine, ç¼–ç¨‹æŠ€å·§, 3Då»ºæ¨¡, æ¸¸æˆè®¾è®¡*
